<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="author" content="Marcos Irigoyen">
<title>Programação Paralela</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="paralelismo-threads-openmp-tasks" class="book toc2 toc-left text-justify">
<div id="header" style="max-width: 80%;">
<h1>Programação Paralela</h1>
<div class="details">
<span id="author" class="author">Marcos Irigoyen</span><br>
<span id="email" class="email"><a href="mailto:mvbirigoyen@gmail.com">mvbirigoyen@gmail.com</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Sumário</div>
<p><span class="toc-root"><a href="index.html">Programação Paralela</a></span></p><ul class="sectlevel1">
<li><a href="gargalo-de-von-neumann.html">Gargalo de Von Neumann e a Cache</a>
</li>
<li><a href="pipelining-e-vetorizacao.html">Pipelining e Vetorização</a>
</li>
<li><a href="fontes-de-demanda-por-performance-precisao.html">Fontes de demanda por performance: precisão</a>
</li>
<li><a href="multithreading-e-threads-de-hardware.html">Threading por hardware e hyperthreading</a>
</li>
<li><a href="paralelismo-threads-openmp-for.html">Paralelismo por Threads com OpenMP</a>
</li>
<li><a href="paralelismo-threads-openmp-escopos-critical.html">Paralelismo por Threads com OpenMP: Escopo e seções críticas</a>
</li>
<li><a href="paralelismo-threads-openmp-tasks.html"><span class="toc-current">Paralelismo por Threads com OpenMP: Tasks</span></a>
<ul class="sectlevel2">
<li><a href="paralelismo-threads-openmp-tasks.html#_introdução_7">Introdução</a>
</li>
<li><a href="paralelismo-threads-openmp-tasks.html#_experimento_5">Experimento</a>
</li>
<li><a href="paralelismo-threads-openmp-tasks.html#_relacionados_7">Relacionados</a>
</li>
<li><a href="paralelismo-threads-openmp-tasks.html#_íntegra_dos_códigos_7">Íntegra dos códigos</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content" style="max-width: 80%;">
<div class="sect1">
<h2 id="paralelismo-threads-openmp-tasks">Paralelismo por Threads com OpenMP: Tasks</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introdução_7">Introdução</h3>
<div class="paragraph">
<p>Com um <code>for parallel</code> e criatividade você consegue ir longe e rápido em OpenMP. Com tasks você consegue ir mais longe
ainda — mas nem sempre na velocidade que você deseja. Se você viu a primeira postagem desse assunto (Paralelismo por
Threads com OpenMP), você viu duas implementações paralelas do Crivo de Erastóstenes com resultados muito distintos: uma versão baseada em laços paralelos que, para um N grande o bastante, era mais rápida que a versão serial, e uma versão em
tasks que não só piorava conforme aumentava o número de threads, como que era mais lenta que a versão serial para
qualquer tamanho do problema. Abordaremos aqui como paralelizar um programa por tasks com OpenMP usando uma aplicação
hipótetica (requisito), percorremos recursivamente todo o conteúdo de um diretório (assumindo apenas arquivos e pastas,
nada de link simbólico ou bagunças do tipo) e operando sobre seus arquivos, partindo de uma versão serial para uma
primeira versão baseada em tasks e por fim uma versão otimizada dela, fazendo uma análise temporal com um tempo
artificial de operação e uma análise mais ágil contabilizando custos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_experimento_5">Experimento</h3>
<div class="paragraph">
<p>A atividade requisito pede que acessemos uma lista encadeada com arquivos fantasia e operássemos em paralelo com eles
usando tasks: como não conseguiríamos saber o tamanho da task sem iterar pelos arquivos, teríamos que criar tasks para
paralelizar o processamento enquanto fazemos o fetching dos arquivos. Para dar mais veracidade, usei o <code>dirent.h</code> do
libc para percorrer uma árvore de diretórios real (real, mas feita com shell script exatamente pra esse teste). Sua
versão serial segue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">unsigned int file_operation(std::string name, unsigned long level, unsigned long file_delay){
    print_mode==REGULAR &amp;&amp; printf("%s [file] [T%d]\n",(std::string(level, '\t')+name).c_str(), omp_get_thread_num());
    dummy_file_operation_overhead(file_delay);
    alt_cost += DEFAULT_FILE_COST;
    return 1;
}

unsigned int folder_operation_serial(DIR* folder_entry, std::string path, std::string name, unsigned long level, unsigned long file_delay){
    print_mode==REGULAR &amp;&amp; printf("%s [folder] [T%d]\n",(std::string(level, '\t')+name).c_str(), omp_get_thread_num());
    alt_cost += DEFAULT_FOLDER_COST;
    return 1 + tree_recursive_serial(folder_entry, path+"/", level+1);
}

unsigned long tree_recursive_serial(DIR* dir_ptr, std::string prefix, unsigned int level, unsigned int file_delay){

    unsigned long res = 0;
    for (dirent64* entry = readdir64(dir_ptr); entry != NULL; entry = readdir64(dir_ptr)){

        const std::string name = entry-&gt;d_name;
        if (name == "." || name == ".."){continue;}
        const auto path = prefix + name;

        DIR* sub_entry = handled_opendir(path.c_str());
        if (sub_entry == NULL){
            res += file_operation(name, level, file_delay);
        } else {
            res += folder_operation_serial(sub_entry, path, name, level, file_delay);
        }
    }
    closedir(dir_ptr);
    return res;
}

return_data tree_serial(const char* root_path, unsigned long num_threads){
    auto start = utils::mark_time();
    DIR *base = handled_opendir(root_path);
    unsigned long total_files = tree_recursive_serial(base, root_path);
    auto end = utils::mark_time();
    if constexpr (alternative_cost_mode){
        return {alt_cost, utils::calc_time_interval_ms(start, end)};
    } else {
        return {total_files, utils::calc_time_interval_ms(start, end)};
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>OBS.: Vale notar que em ambos os casos ainda escapamos de um fator importantíssimo no tempo de execução de problemas
desse tipo — a latência de acesso. Se você está, por exemplo, requisitando informações de um servidor remoto, você
provavelmente já estará ganhando muito na redução de tempo de execução e nem tenha como melhorar mais, por ser
basicamente um programa "memory-bounded". Aqui você perceberá um ligeiro erro meu envolvendo isso, mas como ninguém lê
eu deixo como exercício ao leitor encontrá-lo.</p>
</div>
<div class="paragraph">
<p>Olhando seu funcionamento, é simples: abrimos um diretório e começamos a iterar sob seu conteúdo; se o conteúdo for
arquivo, processamos o arquivo, se o conteúdo for uma pasta, iteramos pelo conteúdo da pasta dessa mesma forma. Contamos
quantas entradas tem no total como uma verificação simples e incompleta do funcionamento (também é printado na stdout
de um jeito parecido ao <code>tree</code> do&#8230;&#8203; MS-DOS?) e outras contagens de custo que servirão pra depois. Para paralelizar este algoritmo, podemos criar tasks para cada entrada do diretório durante sua iteração, permitindo que aproveitemos parte
dos recursos enquanto esperamos a próxima entrada. Se você se lembra do último programa com tasks que abordamos, isso
não deu certo: o overhead de criação da task não compensava o tempo de execução do programa. Para amenizar isso, então,
poderíamos criar tasks somente para os subdiretórios, onde a recursão para iterar neles pode ser muito custosa. Uma
primeira versão paralela assim, então, seria:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">unsigned int folder_operation_task(DIR* folder_entry, std::string path, std::string name, unsigned long level, unsigned long file_delay){
    print_mode==REGULAR &amp;&amp; printf("%s [folder] [T%d]\n",(std::string(level, '\t')+name).c_str(), omp_get_thread_num());
    #pragma omp task
    {
                file_count += tree_recursive_task(folder_entry, path+"/", level+1);
    }
    alt_cost += DEFAULT_FOLDER_COST;
    return 1;
}

unsigned long tree_recursive_task(DIR* dir_ptr, std::string prefix, unsigned int level,
    unsigned int file_delay, unsigned int file_task_block){

    unsigned long res = 0;
    for (dirent64* entry = readdir64(dir_ptr); entry != NULL; entry = readdir64(dir_ptr)){

        const std::string name = entry-&gt;d_name;
        if (name == "." || name == ".."){continue;}
        const auto path = prefix + name;

        DIR* sub_entry = handled_opendir(path.c_str());
        if (sub_entry == NULL){
            res += file_operation(name, level, file_delay);
        } else {
            res += folder_operation_task(sub_entry, path, name, level, file_delay);
        }
    }
    closedir(dir_ptr);
    return res;
}

template &lt;auto recursive_func&gt; //especializado para recursive_func = tree_recursive_task
return_data tree_parallel(const char* root_path, unsigned long num_threads){
    auto start = utils::mark_time();
    DIR *base = handled_opendir(root_path);
    unsigned long total_files = 0;
    unsigned long total_alt_cost = 0;
    #pragma omp parallel num_threads(num_threads) reduction(+:total_files)
    {
        #pragma omp single
        {
            file_count += recursive_func(base, root_path, 0, DEFAULT_FILE_OPERATION_OVERHEAD, DEFAULT_FILE_BLOCK_SIZE);
        }
        #pragma omp barrier
        total_files = file_count;
        #pragma omp critical
        {
            total_alt_cost = total_alt_cost &gt; alt_cost ? total_alt_cost : alt_cost;
        }
        #pragma omp barrier
        alt_cost = total_alt_cost;
    }

    auto end = utils::mark_time();
    if constexpr (alternative_cost_mode){
        return {total_alt_cost, utils::calc_time_interval_ms(start, end)};
    } else {
        return {total_files, utils::calc_time_interval_ms(start, end)};
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>E por aí já poderíamos parar, mas ainda tem potencial dentro disso. A ordem de acesso às entradas de um diretório não
tem ordem definida, então você pode iterar por todos os arquivos de um diretório para, no final, chegar a um
subdiretórios — efetivamente pior que uma versão serial. Como não há latência significante para o acesso da próxima
entrada, podemos fazer o seguinte: iteramos por todas as entradas do diretório, guardando temporiariamente as entradas
que são arquivos em um buffer e criando imediatamente as tasks para os diretórios. Com isso, não só resolvemos o
problema da ordem de acesso, mas obtemos algo interessantíssimo: o tamanho da carga. Se estivéssemos em uma seção
paralela comum, poderíamos jogar uma diretiva <code>for</code> e sair comemorando, mas tasks, sendo executadas por uma única
thread, são efetivamente seriais para isso, com o efeito colateral de, caso use uma diretiva ´parallel for´, vá criar
threads virtuais para realizar o trabalho (que aí já são outros fatores e mais trabalho para tradeoff, mas em geral se
deseja evitar). Para contornar isso, vamos ter que usar tasks para paralelizar, mas vamos usar algo que já foi visto na
segunda postagem dessa série (série como esse Programação Paralela como um todo): execuções em bloco. Repartimos a carga
em blocos de até um certo tamanho (aqui determinado arbitrariamente, mas poderia ser calculado) e criamos tasks para
operar nesses blocos, diminuindo a granularidade das tasks em troca de menos overheads de criação de tasks. O código com
essas otimizações fica com as seguintes alterações:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">unsigned int folder_operation_task_optmized(DIR* folder_entry, std::string path, std::string name, unsigned long level, unsigned long file_delay){
    print_mode==REGULAR &amp;&amp; printf("%s [folder] [T%d]\n",(std::string(level, '\t')+name).c_str(), omp_get_thread_num());
    #pragma omp task
    {
                file_count += tree_recursive_task_optimized(folder_entry, path+"/", level+1);
    }
    alt_cost += DEFAULT_FOLDER_COST;
    return 1;
}

unsigned long tree_recursive_task_optimized(DIR* dir_ptr, std::string prefix,
    unsigned int level, unsigned int file_delay, unsigned int file_task_block){

    minimal_queue&lt;std::string&gt; file_queue(DEFAULT_STARTING_QUEUE_SIZE);
    unsigned long res = 0;
    for (dirent64* entry = readdir64(dir_ptr); entry != NULL; entry = readdir64(dir_ptr)){

        const std::string name = entry-&gt;d_name;
        if (name == "." || name == ".."){continue;}
        auto path = prefix + name;
        DIR* sub_entry = handled_opendir(path.c_str());

        if (sub_entry == NULL){
            file_queue.push(name);
        } else {
            res += folder_operation_task_optmized(sub_entry, path, name, level, file_delay);
        }
    }
    closedir(dir_ptr);

    while (file_queue.size &gt; 0){
        std::string* names = new std::string[file_task_block];
        unsigned long block_size = file_queue.popN(file_task_block, names);
        #pragma omp task firstprivate(names, block_size, level)
        {
            for (int i = 0; i &lt; block_size; i++){
                file_count += file_operation(names[i], level, file_delay);
            }
            delete[] names;
        }
    }

    return res;
}

template &lt;auto recursive_func&gt; //especialização de recursive_func para tree_recursive_task_optimized
return_data tree_parallel(const char* root_path, unsigned long num_threads);</code></pre>
</div>
</div>
<div class="paragraph">
<p>E provavelmente você sentiu falta de uma comparação entre a primeira versão com task e a versão serial para justificar
a dedicação de mais esforços para otimizar. Isso foi uma falha minha: só preparei os gráficos com os três juntos, então
apelei para uma noção não necessariamente real de "ainda dá pra melhorar, dá pra ver que dá". O certo é medir antes.
De qualquer forma, ambas as versões são mais lentas que a versão serial se você só quiser contar entradas ou printar uma
árvore: são tarefas baratas demais para que valha a pena criar uma thread. Por conta disso, você talvez tenha reparado
a função <code>dummy_file_operation_overhead</code>: ela serve para simular uma operação cara computacionalmente, esperando os
tanto segundos que lhe forem passados como argumento. Aplicações semelhantes a essa que possam aproveitar de paralelismo
são custosas, como na compilação de uma base de códigos: a compilação inicial de cada arquivo em objetos pode ser feita
assim, como você pode ter feito ao executar um <code>make -j</code>. Enfim, seguem os resultados com tempo artificial:</p>
</div>
<div style="page-break-after: always;"></div>
<div id="plot_wrapper1" style="display:flex; flex-direction:column">
    <div id="plot_times1" style="margin:auto;width:55%;aspect-ratio: 16 / 9">Se você está vendo isso aqui, o script do plot deu pau</div>
</div>
<div class="paragraph">
<p>Como visto, é possível de se aproveitar do paralelismo por tasks para aplicações do tipo, mas é necessário análise da
carga e fatores adjacentes, como latência de acesso. Uma forma mais prática de executar esses testes é abandonando esse
tempo artificial: ao invés de medir o tempo, posso definir uma variável global (global de escopo normal,privada no
escopo de compartilhamento) de custo e atribua valores para diferentes tipos de operações. Ao realizá-las, incremento a
variável custo pelos seus valores e, no final da seção paralela, mantenho o maior valor dentre as threads. Efetivamente,
obtenho uma combinação de operações executadas e custos de natureza parecida com o tempo de execução, onde o quão mais
fidedignos forem os valores atribuídos às operações ao seu custo computacional, mais próximo essa variável custo é do
tempo de execução. Os resultados de cima usaram um custo de 1 para cada operação em arquivo e 0 nas demais operações,
semelhante ao tempo artificial de 1s em cada operação em arquivo. Como esse custo artificial é muito maior que quaisquer
outros custos, vemos (passando o mouse em cima dos pontos no gráfico) que eles são praticamente iguais. Usando, então,
esse truque para medir o tempo de um problema maior (e com mais amostras), temos:</p>
</div>
<div style="page-break-after: always;"></div>
<script src="https://cdn.plot.ly/plotly-3.0.1.min.js" charset="utf-8"></script>
<div id="plot_wrapper2" style="display:flex; flex-direction:column">
    <div id="plot_times2" style="margin:auto;width:55%;aspect-ratio: 16 / 9">Se você está vendo isso aqui, o script do plot deu pau</div>
</div>
<script>
    cache = {}
    async function fetch_data(path, target_element_id, extra){
        var data = []
        if (cache[path]){data = cache[path]; console.log("omggg acertei o cache mais preguiçoso que existe")}
        else{
            const response = await fetch(path)
            data = await response.json()
            cache[path] = data
        }
        processData(data, target_element_id, extra)
    }

    function processData(json_data, target_element_id, extra){

        series = structuredClone(json_data)

        const dash_types = ["solid", "dashdot", "dash"]
        var counter = 0
        for (const [key, val] of Object.entries(series)){
            series[key]["mode"] = "lines+markers"
            series[key]["type"] = "scatter"
            series[key]["name"] = key
            series[key]["line"] = {dash:dash_types[counter]}
            series[key]["text"] = series[key]["extra"].map(x => x.toString())
            counter = (counter+1)
        }
        document.getElementById(target_element_id).innerText = ""
        var traces = Object.values(series)
        Plotly.newPlot(target_element_id, traces,
            {
                title: {text: extra.title, subtitle: {text: `${extra.samples} samples per thread count, ran on a AMD Ryzen 5 7600, compiled with -O2${extra.subtitle_extra}`}},
                xaxis: {title: {text: "Thread count"}},
                yaxis: {title: {text: extra.ylabel}},
            }
        )
    }

    fetch_data(`resources/rel_7_timing_filtered_data.json`, "plot_times1",
    {title:"Pseudo-timing comparison — 50 entries", samples:5, ylabel:"Mean time (ms)", subtitle_extra:""}
    )
    fetch_data(`resources/rel_7_costs_filtered_data.json`, "plot_times2",
    {title:"Arbitrary comparison — 255 entries", samples:30, ylabel:"Mean cost", subtitle_extra:", files cost 1, directories cost 0"}
    )
</script>
<div class="paragraph">
<p>Podemos ver o quão melhoraria o speedup usando os mesmos parâmetros do teste anterior. Como estou animado com
exercícios, considere os seguintes: uma versão baseada em laços paralelos (que agora sabemos que é possível); estimar
pesos para diferentes operações, como criação de task, operação em diretório, buffering de entradas, etc.; e refatorar
o script <code>make_random_dirtree.sh</code> para aceitar árvores com mais de 255 entradas (/s).</p>
</div>
</div>
<div class="sect2">
<h3 id="_relacionados_7">Relacionados</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://medium.com/@codingcamel/learning-in-public-coding-ls-in-c-part-1-ab70eda85551">Esta postagem</a> me guiou para o <code>dirent.h</code>, de onde eu segui <a href="https://pubs.opengroup.org/onlinepubs/7908799/xsh/dirent.h.html">esta documentação</a> para implementar o acesso aos arquivos
(de forma compatível com o POSIX.1!).</p>
</li>
<li>
<p><a href="https://youtu.be/u0qqwTGjHmQ?list=PLoOmvuyo5UAfFSqAhftxmS2nX1ZTa7SCU">Esta videoaula</a> do Hasso Plattner Institut
dá uma boa visão geral e contextualização do assunto, uma pena não terem mais dos temas que abordo.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_íntegra_dos_códigos_7">Íntegra dos códigos</h3>
<details>
<summary class="title">main.cpp</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">#include &lt;cstdio&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
#include &lt;cerrno&gt;
#include "utils.h"
#include &lt;dirent.h&gt;
#include &lt;omp.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

//config used for timing test:
const unsigned long DEFAULT_FILE_OPERATION_OVERHEAD = 1;
const unsigned long DEFAULT_STARTING_QUEUE_SIZE = 10;
const unsigned long DEFAULT_FILE_BLOCK_SIZE = 5;

const bool alternative_cost_mode = false;
const unsigned long DEFAULT_FILE_COST = 1;
const unsigned long DEFAULT_FOLDER_COST = 0;

//config used for cost measurement
//const unsigned long DEFAULT_FILE_OPERATION_OVERHEAD = 0;
//const unsigned long DEFAULT_STARTING_QUEUE_SIZE = 10;
//const unsigned long DEFAULT_FILE_BLOCK_SIZE = 5;
//
//const bool alternative_cost_mode = false;
//const unsigned long DEFAULT_FILE_COST = 1;
//const unsigned long DEFAULT_FOLDER_COST = 0;

enum PRINT_MODE {
    REGULAR,
    CSV
};

PRINT_MODE print_mode = REGULAR; //had to move it here as i wanted to print pretty trees

std::unordered_map&lt;std::string, PRINT_MODE&gt; print_flags = {
    {"-printCSV", CSV},
};

unsigned long file_count = 0;
#pragma omp threadprivate(file_count)

unsigned long alt_cost = 0;
#pragma omp threadprivate(alt_cost)

typedef utils::_return_data&lt;unsigned long&gt; return_data;

//oh dear, look! it's the minimal_queue from 2 tasks ago!
template &lt;typename T&gt;
struct minimal_queue {
    T* front = nullptr;
    T* end = nullptr;
    T* push(T value);
    T* push_front(T value);
    T pop();
    long popN(unsigned long N, T* out_ptr);
    bool empty() const {return size == 0;};
    unsigned long size = 0;
    unsigned long start_offset = 0;
    unsigned long max_elements;
    T* buffer;
    void realloc_buffer(unsigned long new_max);
    minimal_queue(unsigned long max_elements) : max_elements(max_elements), buffer(new T[max_elements]){}
    ~minimal_queue(){delete[] buffer;}
};

template &lt;typename T&gt;
void minimal_queue&lt;T&gt;::realloc_buffer(unsigned long new_max){
    T* new_buf = new T[new_max];
    long before_wrap = max_elements - start_offset;
    before_wrap = before_wrap &gt; size ? size : before_wrap; //tmp as min(size, tmp)
    long after_wrap = size &gt; before_wrap ? size - before_wrap : 0; //complement as how many elements wrapped around the buffer
    
    if constexpr (std::is_trivially_copyable&lt;T&gt;::value){
        std::memcpy(new_buf, this-&gt;buffer + (this-&gt;start_offset), before_wrap*sizeof(T));
        std::memcpy(new_buf + before_wrap, this-&gt;buffer, after_wrap*sizeof(T));
        printf("memcpy de novo??\n");
    } else {
        for (auto i = 0; i &lt; before_wrap; i++){
            new_buf[i] = std::move(buffer[start_offset + i]);
        }
        for (auto i = 0; i &lt; after_wrap; i++){
            new_buf[before_wrap+i] = std::move(buffer[i]);
        }
    }
    delete[] this-&gt;buffer;
    this-&gt;buffer = new_buf;
    this-&gt;max_elements=new_max;
}

//leaving push() to a full queue as UB, check size first
template &lt;typename T&gt;
T* minimal_queue&lt;T&gt;::push(T value){
    if (this-&gt;size == this-&gt;max_elements){
        this-&gt;realloc_buffer(this-&gt;max_elements*2);
    }
    T* const ptr = this-&gt;buffer + ((this-&gt;start_offset + this-&gt;size)%this-&gt;max_elements);
    *ptr = value;
    if (this-&gt;empty()){
        this-&gt;front = ptr;
    }
    this-&gt;end = ptr;
    this-&gt;size++;
    return ptr;
}

//leaving push() to a full queue as UB, check size first
template &lt;typename T&gt;
T* minimal_queue&lt;T&gt;::push_front(T value){
    if (this-&gt;size == this-&gt;max_elements){
        this-&gt;realloc_buffer(this-&gt;max_elements*2);
    }
    this-&gt;start_offset = (this-&gt;start_offset-1)%this-&gt;max_elements;
    T* const ptr = this-&gt;buffer + this-&gt;start_offset;
    *ptr = value;
    if (this-&gt;empty()){
        this-&gt;end = ptr;
    }
    this-&gt;front = ptr;
    this-&gt;size++;
    return ptr;
}

template &lt;typename T&gt;
long minimal_queue&lt;T&gt;::popN(unsigned long N, T* dest_ptr){
    const long res = this-&gt;size &gt; N ? N : this-&gt;size;
    const long before_wrap = (max_elements - start_offset) &gt; res ? res : (max_elements - start_offset);
    const long after_wrap = res &gt; before_wrap ? res - before_wrap : 0;

    if constexpr (std::is_trivially_copyable&lt;T&gt;::value){
        std::memcpy(dest_ptr, this-&gt;buffer + (this-&gt;start_offset), before_wrap*sizeof(T));
        std::memcpy(dest_ptr + before_wrap, this-&gt;buffer, after_wrap*sizeof(T));
    } else {
        for (long i = 0; i &lt; before_wrap; i++){
            dest_ptr[i] = std::move(this-&gt;buffer[start_offset + i]);
        }
        for (long i = 0; i &lt; after_wrap; i++){
            dest_ptr[before_wrap+i] = std::move(this-&gt;buffer[i]);
        }
    }
    
    this-&gt;size -= res;
    this-&gt;start_offset = (this-&gt;start_offset+res)%this-&gt;max_elements;
    
    if (this-&gt;size == 0){
        this-&gt;front = nullptr;
        this-&gt;end = nullptr;
    } else {
        this-&gt;front = this-&gt;buffer + this-&gt;start_offset;
    }
    return res;
}

//leaving a pop() to an empty queue as UB, check empty() first
template &lt;typename T&gt;
T minimal_queue&lt;T&gt;::pop(){
    T value = *(this-&gt;front);
    this-&gt;start_offset = (this-&gt;start_offset+1)%this-&gt;max_elements;
    if (size == 1){
        this-&gt;front = nullptr;
        this-&gt;end = nullptr;
    } else{
        this-&gt;front = this-&gt;buffer + this-&gt;start_offset;
    }
    this-&gt;size--;
    return value;
}

void dummy_file_operation_overhead(unsigned int seconds){
    sleep(seconds);
}

//as POSIX.1 struct dirent has no file type identifier, i'll be using its opendir errno to work around.
//by definition errno should be thread safe. let's hope it is
DIR* handled_opendir(const char* dirname){
    DIR* res = opendir(dirname);
    if (res == NULL){ //using NULL instead of nullptr because dirent is from libc? no good reason actually but w/e
        switch (errno)
        {
        case EACCES:
            printf("Permission denied for %s\n", dirname);
            break;
        case EMFILE:
        case ENFILE:
            printf("Limit exceeded :( failed at %s\n", dirname);
            break;
        case ENAMETOOLONG:
            printf("%s exceeds the path's name limit!?\n", dirname);
            break;
        case ENOENT:
            printf("There is no existing %s file or similar\n", dirname);
            break;
        case ENOTDIR:    
            //resetting it here so i won't need to in the readdir() loop
            errno = 0;
            return res;
            break;
        default:
            printf("%s seems to really mess around\n", dirname);
            break;
        }
        exit(1);
    }
    return res;
}

unsigned long tree_recursive_serial(DIR* dir_ptr, std::string prefix="", unsigned int level = 0,
    unsigned int file_delay=DEFAULT_FILE_OPERATION_OVERHEAD);

unsigned long tree_recursive_task(DIR* dir_ptr, std::string prefix="", unsigned int level = 0,
    unsigned int file_delay=DEFAULT_FILE_OPERATION_OVERHEAD, unsigned int file_task_block=DEFAULT_FILE_BLOCK_SIZE);

unsigned long tree_recursive_task_optimized(DIR* dir_ptr, std::string prefix="", unsigned int level = 0,
    unsigned int file_delay=DEFAULT_FILE_OPERATION_OVERHEAD, unsigned int file_task_block=DEFAULT_FILE_BLOCK_SIZE);

unsigned int file_operation(std::string name, unsigned long level, unsigned long file_delay){
    print_mode==REGULAR &amp;&amp; printf("%s [file] [T%d]\n",(std::string(level, '\t')+name).c_str(), omp_get_thread_num());
    dummy_file_operation_overhead(file_delay);
    alt_cost += DEFAULT_FILE_COST;
    return 1;
}

unsigned int folder_operation_serial(DIR* folder_entry, std::string path, std::string name, unsigned long level, unsigned long file_delay){
    print_mode==REGULAR &amp;&amp; printf("%s [folder] [T%d]\n",(std::string(level, '\t')+name).c_str(), omp_get_thread_num());
    alt_cost += DEFAULT_FOLDER_COST;
    return 1 + tree_recursive_serial(folder_entry, path+"/", level+1);
}

unsigned int folder_operation_task(DIR* folder_entry, std::string path, std::string name, unsigned long level, unsigned long file_delay){
    print_mode==REGULAR &amp;&amp; printf("%s [folder] [T%d]\n",(std::string(level, '\t')+name).c_str(), omp_get_thread_num());
    #pragma omp task
    {           
                file_count += tree_recursive_task(folder_entry, path+"/", level+1);
    }
    alt_cost += DEFAULT_FOLDER_COST;
    return 1;
}

unsigned int folder_operation_task_optmized(DIR* folder_entry, std::string path, std::string name, unsigned long level, unsigned long file_delay){
    print_mode==REGULAR &amp;&amp; printf("%s [folder] [T%d]\n",(std::string(level, '\t')+name).c_str(), omp_get_thread_num());
    #pragma omp task
    {
                file_count += tree_recursive_task_optimized(folder_entry, path+"/", level+1);
    }
    alt_cost += DEFAULT_FOLDER_COST;
    return 1;
}

unsigned long tree_recursive_serial(DIR* dir_ptr, std::string prefix, unsigned int level, unsigned int file_delay){
    
    unsigned long res = 0;
    for (dirent64* entry = readdir64(dir_ptr); entry != NULL; entry = readdir64(dir_ptr)){
        
        const std::string name = entry-&gt;d_name;
        if (name == "." || name == ".."){continue;}
        const auto path = prefix + name;

        DIR* sub_entry = handled_opendir(path.c_str());
        if (sub_entry == NULL){
            res += file_operation(name, level, file_delay);
        } else {
            res += folder_operation_serial(sub_entry, path, name, level, file_delay);
        }
    }
    closedir(dir_ptr);
    return res;
}

unsigned long tree_recursive_task(DIR* dir_ptr, std::string prefix, unsigned int level,
    unsigned int file_delay, unsigned int file_task_block){

    unsigned long res = 0;    
    for (dirent64* entry = readdir64(dir_ptr); entry != NULL; entry = readdir64(dir_ptr)){
        
        const std::string name = entry-&gt;d_name;
        if (name == "." || name == ".."){continue;}
        const auto path = prefix + name;
        
        DIR* sub_entry = handled_opendir(path.c_str());
        if (sub_entry == NULL){
            res += file_operation(name, level, file_delay);
        } else {
            res += folder_operation_task(sub_entry, path, name, level, file_delay);
        }
    }
    closedir(dir_ptr);
    return res;
}

unsigned long tree_recursive_task_optimized(DIR* dir_ptr, std::string prefix,
    unsigned int level, unsigned int file_delay, unsigned int file_task_block){
    
    minimal_queue&lt;std::string&gt; file_queue(DEFAULT_STARTING_QUEUE_SIZE);
    unsigned long res = 0;
    for (dirent64* entry = readdir64(dir_ptr); entry != NULL; entry = readdir64(dir_ptr)){
        
        const std::string name = entry-&gt;d_name;
        if (name == "." || name == ".."){continue;}
        auto path = prefix + name;
        DIR* sub_entry = handled_opendir(path.c_str());
        
        if (sub_entry == NULL){
            file_queue.push(name);
        } else {
            res += folder_operation_task_optmized(sub_entry, path, name, level, file_delay);
        }
    }
    closedir(dir_ptr);

    while (file_queue.size &gt; 0){
        std::string* names = new std::string[file_task_block];
        unsigned long block_size = file_queue.popN(file_task_block, names);
        #pragma omp task firstprivate(names, block_size, level)
        {
            for (int i = 0; i &lt; block_size; i++){
                file_count += file_operation(names[i], level, file_delay);
            }
            delete[] names;
        }
    }

    return res;
}

return_data tree_serial(const char* root_path, unsigned long num_threads){    
    auto start = utils::mark_time();
    DIR *base = handled_opendir(root_path);
    unsigned long total_files = tree_recursive_serial(base, root_path);
    auto end = utils::mark_time();
    if constexpr (alternative_cost_mode){
        return {alt_cost, utils::calc_time_interval_ms(start, end)};
    } else {
        return {total_files, utils::calc_time_interval_ms(start, end)};
    }
}

template &lt;auto recursive_func&gt;
return_data tree_parallel(const char* root_path, unsigned long num_threads){
    auto start = utils::mark_time();
    DIR *base = handled_opendir(root_path);
    unsigned long total_files = 0;
    unsigned long total_alt_cost = 0;
    #pragma omp parallel num_threads(num_threads) reduction(+:total_files)
    {
        #pragma omp single
        {
            file_count += recursive_func(base, root_path, 0, DEFAULT_FILE_OPERATION_OVERHEAD, DEFAULT_FILE_BLOCK_SIZE);
        }
        #pragma omp barrier
        total_files = file_count;
        #pragma omp critical
        {
            total_alt_cost = total_alt_cost &gt; alt_cost ? total_alt_cost : alt_cost;
        }
        #pragma omp barrier
        alt_cost = total_alt_cost;
    }
    
    auto end = utils::mark_time();
    if constexpr (alternative_cost_mode){
        return {total_alt_cost, utils::calc_time_interval_ms(start, end)};
    } else {
        return {total_files, utils::calc_time_interval_ms(start, end)};
    }
}

typedef return_data (*target_func_ptr)(const char*, unsigned long);

std::unordered_map&lt;std::string, target_func_ptr&gt; modes = {
    {"SERIAL", tree_serial},
    {"TASK_PARALLEL", tree_parallel&lt;tree_recursive_task&gt;},
    {"TASK_PARALLEL_OPTIMIZED", tree_parallel&lt;tree_recursive_task_optimized&gt;},
};

int main(int argc, char* argv[]){
    if (argc &lt; 4){
        printf("Insufficient arguments, use: %s &lt;MODE&gt; &lt;DIR_PATH&gt; &lt;NUM_THREADS&gt; [-printCSV]\n", argv[0]);
        printf("&lt;MODE&gt; being either SERIAL, TASK_PARALLEL or TASK_PARALLEL_OPTIMIZED\n");
        exit(1);
    } else{
        if (argc &gt; 5) {
            printf("Too many arguments starting at %s. Use: %s &lt;MODE&gt; &lt;DIR_PATH&gt; &lt;NUM_THREADS&gt; [-printCSV]\n",
                argv[5], argv[0]);
            exit(1);
        }
        if (argc == 5){
            auto temp_print = print_flags.find(argv[4]);
            if (temp_print == print_flags.end()){
                printf("Invalid argument: %s. Usage: %s &lt;MODE&gt; &lt;DIR_PATH&gt; &lt;NUM_THREADS&gt; [-printCSV]\n",
                    argv[4], argv[0]);
                exit(1);
            }
            print_mode = temp_print-&gt;second;
        }
    }

    auto mode = modes.find(argv[1]);
    if (mode == modes.end()){
        printf("Invalid mode: %s. Choose between SERIAL, TASK_PARALLEL or TASK_PARALLEL_OPTIMIZED\n", argv[1]);
        exit(1);
    }

    target_func_ptr func = mode-&gt;second;

    //std::string dir_param(argv[2]);
    unsigned long num_threads = std::strtoul(argv[3], NULL, 10);
        if (num_threads == 0 || errno == ERANGE){
            printf("Invalid parameter: %s.\n", argv[3]);
            exit(1);
        }

    return_data exec_data = mode-&gt;second(argv[2], num_threads);

    switch (print_mode){
    case CSV:
        printf("%s, %lu, %lu, %lu, %f\n", argv[1], num_threads, alt_cost, exec_data.res, exec_data.time_ms);
        break;
    default:
        printf("Result for n = %lu: %lu; Total elapsed time: %f ms\n", num_threads, exec_data.res, exec_data.time_ms);
        break;
    }

    return 0;
}</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">make_random_dirtree.sh</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">OUTPUT_PATH=$1
MAX_ENTRIES=$2

BRANCHING_FREQUENCY=0.5
ENTRY_FREQ=0.9

ENTRY_COUNT=0
LEVEL=0
GLOBAL_SEED=`head -c 2 /dev/urandom | od -An -tu2`

TOTAL_COST=0

try_generate(){
    LOCAL_SEED=$(($GLOBAL_SEED+$1))
    awk -v seed="$LOCAL_SEED" -v prob_entry="$ENTRY_FREQ" -v prob_dir="$BRANCHING_FREQUENCY" 'BEGIN {
        srand(seed);
        val1 = rand();
        val2 = rand();
        if (val1 &lt;= prob_entry){
            if (val2 &lt;= prob_dir){
                print "dir";
            } else{
                print "file";
            }
        } else {
            print "nothing";
        }
    }'
}

populate_level() {
    GLOBAL_PROGRESS=$1
    GLOBAL_MAX=$2
    LOCAL_LEVEL=$3
    LOCAL_PATH=$4

    NEXT_LEVEL=$(($LOCAL_LEVEL+1))
    while [ "$GLOBAL_PROGRESS" -lt "$GLOBAL_MAX" ]
    do
        NEXT=`try_generate $GLOBAL_PROGRESS`
        if [ "$NEXT" = "dir" ]
        then
            GLOBAL_PROGRESS=$(($GLOBAL_PROGRESS+1))
            echo mkdir "$LOCAL_PATH/dir_$GLOBAL_PROGRESS"
            mkdir "$LOCAL_PATH/dir_$GLOBAL_PROGRESS"
            
            placeholder=$(populate_level $GLOBAL_PROGRESS $GLOBAL_MAX $NEXT_LEVEL $LOCAL_PATH/dir_$GLOBAL_PROGRESS)
            GLOBAL_PROGRESS=$?
            echo $placeholder
        fi
        if [ "$NEXT" = "file" ]
        then
            GLOBAL_PROGRESS=$(($GLOBAL_PROGRESS+1))
            echo touch "$LOCAL_PATH/file_$GLOBAL_PROGRESS"
            touch "$LOCAL_PATH/file_$GLOBAL_PROGRESS"
        fi
        if [ "$NEXT" = "nothing" ]
        then
            GLOBAL_SEED=$(($GLOBAL_SEED+1))
            if [ "$LOCAL_LEVEL" -gt 0 ]
            then
                echo closing $LOCAL_PATH
                echo $GLOBAL_PROGRESS
                return $GLOBAL_PROGRESS
            fi
            echo rolled nothing at level 0, ignoring
        fi
    done
    return $GLOBAL_PROGRESS
}

if [ -z "$OUTPUT_PATH" ]
then
    echo "Pass the path to an output file, use: $0 &lt;path/to/output&gt; &lt;number_of_elements&gt;"
    exit
fi

if [ -z "$MAX_ENTRIES" ]
then
    echo "Pass the number of elements you want, use: $0 &lt;path/to/output&gt; &lt;number_of_elements&gt;"
    exit
fi

populate_level $ENTRY_COUNT $MAX_ENTRIES 0 $OUTPUT_PATH</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">run_test_costs.sh</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">EXEC_FILE="./a.out"
PYTHON_EXEC=python3

START_THREADS=1
MAX_THREADS=12
THREAD_VALUES=`seq $START_THREADS $MAX_THREADS` #ive got lazy to rewrite back the while loop
MODES="TASK_PARALLEL TASK_PARALLEL_OPTIMIZED"
PROBLEM_DIR="teste_dirtree_255/"
PROBLEM_SIZE=255
NUM_SAMPLES=30

OUTPUT_FILE=$1
STATUS=0

if [ -z "$OUTPUT_FILE" ]
then
    echo "Pass the path to an output file, use: $0 &lt;path/to/output&gt;"
    exit
fi
echo MODE,NUM_THREADS,ALT_COST,ENTRY_COUNT,TIME_MS &gt; $OUTPUT_FILE


for MODE in $MODES
do
    SAMPLE=1
    while [ "$SAMPLE" -le "$NUM_SAMPLES" ]
    do
        if [ "$MODE" != "SERIAL" ]
        then
            for NUM_THREADS in $THREAD_VALUES
            do
                echo running "$EXEC_FILE $MODE $PROBLEM_DIR $NUM_THREADS -printCSV &gt;&gt; $OUTPUT_FILE"
                $EXEC_FILE $MODE $PROBLEM_DIR $NUM_THREADS -printCSV &gt;&gt; $OUTPUT_FILE
                STATUS=$?
                if [ "$STATUS" -ne 0 ]
                then
                    #intended for when the MAT_SIDE is too big for the program to allocate this much memory
                    echo Some error occurred, stopping early.
                    exit
                fi
            done
        else
            echo running "$EXEC_FILE $MODE $PROBLEM_DIR 1 -printCSV &gt;&gt; $OUTPUT_FILE"
            $EXEC_FILE $MODE $PROBLEM_DIR 1 -printCSV &gt;&gt; $OUTPUT_FILE
            STATUS=$?
            if [ "$STATUS" -ne 0 ]
            then
                #intended for when the MAT_SIDE is too big for the program to allocate this much memory
                echo Some error occurred, stopping early.
                exit
            fi
        fi
        SAMPLE=$(($SAMPLE+1))
    done
done</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">run_test_timing.sh</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">EXEC_FILE="./a.out"
PYTHON_EXEC=python3

START_THREADS=1
MAX_THREADS=12
THREAD_VALUES=`seq $START_THREADS $MAX_THREADS` #ive got lazy to rewrite back the while loop
MODES="SERIAL TASK_PARALLEL TASK_PARALLEL_OPTIMIZED"
PROBLEM_DIR="teste_dirtree/"
PROBLEM_SIZE=50
NUM_SAMPLES=5

OUTPUT_FILE=$1
STATUS=0

if [ -z "$OUTPUT_FILE" ]
then
    echo "Pass the path to an output file, use: $0 &lt;path/to/output&gt;"
    exit
fi
echo MODE,NUM_THREADS,ALT_COST,ENTRY_COUNT,TIME_MS &gt; $OUTPUT_FILE


for MODE in $MODES
do
    SAMPLE=1
    while [ "$SAMPLE" -le "$NUM_SAMPLES" ]
    do
        if [ "$MODE" != "SERIAL" ]
        then
            for NUM_THREADS in $THREAD_VALUES
            do
                echo running "$EXEC_FILE $MODE $PROBLEM_DIR $NUM_THREADS -printCSV &gt;&gt; $OUTPUT_FILE"
                $EXEC_FILE $MODE $PROBLEM_DIR $NUM_THREADS -printCSV &gt;&gt; $OUTPUT_FILE
                STATUS=$?
                if [ "$STATUS" -ne 0 ]
                then
                    #intended for when the MAT_SIDE is too big for the program to allocate this much memory
                    echo Some error occurred, stopping early.
                    exit
                fi
            done
        else
            echo running "$EXEC_FILE $MODE $PROBLEM_DIR 1 -printCSV &gt;&gt; $OUTPUT_FILE"
            $EXEC_FILE $MODE $PROBLEM_DIR 1 -printCSV &gt;&gt; $OUTPUT_FILE
            STATUS=$?
            if [ "$STATUS" -ne 0 ]
            then
                #intended for when the MAT_SIDE is too big for the program to allocate this much memory
                echo Some error occurred, stopping early.
                exit
            fi
        fi
        SAMPLE=$(($SAMPLE+1))
    done
done</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">process_data.py</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">import pandas as pd
import matplotlib.pyplot as plt
import sys
import json

if len(sys.argv) &lt; 4: print(f"Too few arguments, use {sys.argv[0]} &lt;input_filepath&gt; &lt;img_output_path&gt; &lt;output_path&gt;"); exit(0)
if len(sys.argv) &gt; 4: print(f"Too many arguments, use {sys.argv[0]} &lt;input_filepath&gt; &lt;img_output_path&gt; &lt;output_path&gt;"); exit(0)

data = pd.read_csv(sys.argv[1])

out_mode = input("which mode? [TIMING | COST] ")

#timing
data = data.groupby(['MODE', 'NUM_THREADS', 'ENTRY_COUNT'], as_index=False).aggregate(
    MEAN_ALT_COST=('ALT_COST','mean'),
    MEAN_TIME_MS=('TIME_MS', 'mean')
)

print(data)

size = (16,9)
fig, ax = plt.subplots(figsize=size)

counter = 0
linestyles = ["-.", "-", ":"]
markers = ["x", "o", "*"]

modes = {mode:{} for mode in pd.unique(data["MODE"])}
for mode in modes.keys():
    filtered = data[data['MODE'] == mode]
    modes[mode]["x"] = [x for x in filtered['NUM_THREADS']]
    match out_mode:
        case "TIMING":
            modes[mode]["y"] = [y for y in filtered['MEAN_TIME_MS']]
            modes[mode]["extra"] = [x for x in filtered['MEAN_ALT_COST']]
        case "COST":
            modes[mode]["extra"] = [y for y in filtered['MEAN_TIME_MS']]
            modes[mode]["y"] = [x for x in filtered['MEAN_ALT_COST']]
        case _:
            print("Invalid mode!")
            exit(1)

    if mode == "SERIAL":
        modes[mode]["x"] = [x for x in range(1, 13)]
        modes[mode]["y"] *= 12
        modes[mode]["extra"] *= 12

    ax.plot(modes[mode]["x"], modes[mode]["y"], label=mode, linestyle=linestyles[counter], marker=markers[counter])
    counter += 1

ax.legend()
ax.set_xlabel("NUM_THREADS")


match out_mode:
    case "TIMING":
        fig.suptitle("Pseudo-timing comparison — 50 entries")
        ax.set_title("5 samples per NUM_THREADS, ran on a AMD Ryzen 5 7600, compiled with -O2, artificial 1s delay on files")
        ax.set_ylabel("Mean time (ms)")
    case "COST":
        fig.suptitle("Arbitrary cost comparison — 255 entries")
        ax.set_title("30 samples per NUM_THREADS, ran on a AMD Ryzen 5 7600, compiled with -O2, files cost 1, directories cost 0")
        ax.set_ylabel("Mean cost")


plt.tight_layout()
fig.savefig(sys.argv[2])

with open(sys.argv[3], "w") as file:
    json.dump(modes, file)</code></pre>
</div>
</div>
</div>
</details>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="paralelismo-threads-openmp-escopos-critical.html">Paralelismo por Threads com OpenMP: Escopo e seções críticas</a> | ↑ Up: <a href="index.html">Programação Paralela</a></p>
</div>
</div>
<div id="footer" style="max-width: 80%;">
<div id="footer-text">
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>